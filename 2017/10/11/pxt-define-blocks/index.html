
<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <link rel="icon" type="image/png" href="/img/robot.png">
  <link rel="stylesheet" href="/css/style.css">
  <title>
    小沙丘的网络漫游记
  </title>
<link rel="stylesheet" href="/css/prism-ghcolors.css" type="text/css"></head>
<body>
  <script>
    if (/mobile/i.test(navigator.userAgent) || /android/i.test(navigator.userAgent)){
      document.body.classList.add('mobile');            
    } else{
      document.body.classList.add('pc');
			document.getElementsByTagName("html")[0].style.fontSize="62.5%";
    }
  </script>
  <div class="container">
<!-- 用于文章页面的顶部，提供返回主页和主题页的按键 -->
<!-- 头部开始 -->

<div id="header">
    <p>小沙丘的网络漫游记
      <span> » 
        <a href="/home/">首页</a>
      </span>
      
      <span> » 
          <a href="/tags/PXT/">
            PXT
          </a>
      </span>
      
    </p>
</div>

<!-- 头部结束 -->



<!-- 分类组件，放置于文章页面的顶部，提供上(或下)一篇导航按键。 -->
<div class="asset-nav">
    <div class="entry-categories">
      <p>分类：
        <span> 
            <a href="/tags/PXT/">
              PXT
            </a>
        </span>
      </p>
    </div>
    <div class="entry-location-mobile">
        <span>
            
            <a href="/2017/10/11/pxt-pxtarget-json/">
              ⇐ 
            </a>
        </span>
        <span>
            
            <a href="/2017/10/11/pxt-shim/">
              ⇒
            </a>
        </span>
    </div>
    <div class="entry-location">
        <P>上一篇：
                <a href="/2017/10/11/pxt-pxtarget-json/">
                    配置pxtarget.json | PXT
                </a>
        </P>
        <P>下一篇：

                <a href="/2017/10/11/pxt-shim/">
                    SHIM | PXT
                </a>
        </P>
    </div>
</div>

<div class="post">
<h1>定义blocks | PXT</h1>
<div class="post-meta">
  <p>作者： Lian</p>
  <p>日期：
    2017年10月11日 19:10
  </p>
</div>
      

<div class="page">
    <h1 id="Defining-blocks"><a href="#Defining-blocks" class="headerlink" title="Defining blocks"></a>Defining blocks</h1><p>This section describes how to annotate your PXT APIs to expose them in the Block Editor.</p>
<p>All the <code>//%</code> annotations are found in TypeScript library files.<br>They can optionally be <a href="/simshim">auto-generated</a> from C++ library files or from TypeScript<br>simulator files.</p>
<h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><p>Each top-level javascript namespace is used to populate a category in the Block Editor toolbox. The name will automatically be capitalized in the toolbox.</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">namespace basic {
    ...
}
</code></pre>
<p>You can also provide a JsDoc comment, color and weight for the namespace, as well as a friendly name (in Unicode).<br>We strongly recommend carefully picking colors as it dramatically impacts<br>that appearance and readability of your blocks. All blocks within the same namespace have the same color so that users can find the category easily from<br>samples.</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">/**
 * Provides access to basic micro:bit functionality.
 */
//% color=190 weight=100 icon="\uf1ec" block="Basic Blocks"
namespace basic {
</code></pre>
<ul>
<li><code>icon</code> icon Unicode character from the icon font to display. The <a href="https://semantic-ui.com/elements/icon.html" target="_blank" rel="external">Semantic UI</a> icon set has been ported from Font Awesome (v4.5.6 at the time of writing), and a full list can be found at <a href="http://fontawesome.io/icons/" target="_blank" rel="external">http://fontawesome.io/icons/</a></li>
<li><code>color</code> should be included in a comment line starting with <code>\\%</code>. The color takes a <strong>hue</strong> value or a HTML color.</li>
</ul>
<p>To have a category appear under the “Advanced” section of the Block Editor toolbox, add the annotation <code>advanced=true</code>.</p>
<h2 id="Blocks"><a href="#Blocks" class="headerlink" title="Blocks"></a>Blocks</h2><p>All <strong>exported</strong> functions with a <code>block</code> attribute will be available in the Block Editor.</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">//% block
export function showNumber(v: number, interval: number = 150): void
{ }
</code></pre>
<p>If you need more control over the appearance of the block,<br>you can specify the <code>blockId</code> and <code>block</code> parameters.</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">//% blockId=device_show_number
//% block="show|number %v"
export function showNumber(v: number, interval: number = 150): void
{ }
</code></pre>
<ul>
<li><code>blockId</code> is a constant, unique id for the block. This id is serialized in block code so changing it will break your users.</li>
<li><code>block</code> contains the syntax to build the block structure (more below).</li>
</ul>
<p>Other optional attributes can also be used:</p>
<ul>
<li><code>blockExternalInputs=</code> forces <code>External Inputs</code> rendering</li>
<li><code>advanced=true</code> causes this block to be placed under the parent category’s “More…” subcategory. Useful for hiding advanced or rarely-used blocks by default</li>
</ul>
<h2 id="Block-syntax"><a href="#Block-syntax" class="headerlink" title="Block syntax"></a>Block syntax</h2><p>The <code>block</code> attribute specifies how the parameters of the function<br>will be organized to create the block.</p>
<pre><code>block = field, { &#39;|&#39; field }
field := string
    | string `%` parameter [ `=` type ]
parameter = string
type = string
</code></pre><ul>
<li>each <code>field</code> is mapped to a field in the block editor</li>
<li>the function parameter are mapped <strong>in order</strong> to <code>%parameter</code> argument. The loader automatically builds<br>a mapping between the block field names and the function names.</li>
<li>the block will automatically switch to external inputs when enough parameters are detected</li>
<li>A block type <code>=type</code> can be specified optionally for each parameter. It will be used to populate the shadow type.</li>
</ul>
<h2 id="Supported-types"><a href="#Supported-types" class="headerlink" title="Supported types"></a>Supported types</h2><p>The following types are supported in function signatures that are meant to be exported:</p>
<ul>
<li><code>number</code> (TypeScript) or <code>int</code> (C++)</li>
<li><code>string</code> (TypeScript) or <code>StringData*</code> (C++)</li>
<li>enums (see below)</li>
<li>custom classes that are also exported</li>
<li>arrays of the above</li>
</ul>
<h2 id="Callbacks-with-Parameters"><a href="#Callbacks-with-Parameters" class="headerlink" title="Callbacks with Parameters"></a>Callbacks with Parameters</h2><p>APIs that take in a callback function will have that callback converted into a statement input.<br>If the callback in the API is designed to take in parameters, the best way to map that pattern<br>to the blocks is by passing the callback a single parameter with a class type that contains<br>all the other values. For example:</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">export class ArgumentClass {
    argumentA: number;
    argumentB: string;
}

//% mutate=objectdestructuring
//% mutateText="My Arguments"
//% mutateDefaults="argumentA;argumentA,argumentB"
// ...
export function addSomeEventHandler((a: ArgumentClass) => void) { };
</code></pre>
<p>In the above example, setting <code>mutate=objectdestructuring</code> will cause this API to use Blockly “mutators”<br>to let users change what parameters appear in the blocks. Each parameter will be given an<br>optional variable field in the block that defines a variable that can be used within the callback.<br>The variable fields compile to object destructuring in the TypeScript code. For example:</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">addSomeEventHandler(({argumentA, argumentB}) => {

})
</code></pre>
<p>For an example of this pattern in action, see the <code>radio.onDataPacketReceived</code> block in<br>the microbit target.</p>
<p>In some cases it can be useful to change the runtime behavior of the API based on the properties selected by the<br>user. To enable that behavior, create an enum with entries that have the same names as the argument object’s<br>properties and add an extra parameter taking in an enum array to the API. For example:</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">export class ArgumentClass {
    argumentA: number;
    argumentB: string;
}

enum ArgNames {
    argumentA,
    argumentB
}

//% mutate=objectdestructuring
//% mutateText="My Arguments"
//% mutateDefaults="argumentA;argumentA,argumentB"
//% mutatePropertyEnum="argNames"
// ...
export function addSomeEventHandler(args: ArgNames[], (a: ArgumentClass) => void) { };
</code></pre>
<p>Note the <code>mutatePropertyEnum</code> attribute added to the comment annotations. The block for this API will<br>look the same as the previous example but the compiled code will also include the arguments passed:</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">addSomeEventHandler([ArgNames.argumentA, ArgNames.argumentB], ({argumentA, argumentB}) => {

})
</code></pre>
<p>The other attributes related to object destructuring mutators include:</p>
<ul>
<li><code>mutateText</code> - defines the text that appears in the top block of the Blockly mutator dialog (the dialog that appears when you click the blue gear)</li>
<li><code>mutateDefaults</code> - defines the versions of this block that should appear in the toolbox. Block definitions are separated by semicolons and property names should be separated by commas</li>
</ul>
<h2 id="Enums"><a href="#Enums" class="headerlink" title="Enums"></a>Enums</h2><p>Enum are supported and will automatically be represented by a dropdown in blocks.</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">enum Button {
    A = 1,
    B = 2,
    //% blockId="ApB" block="A+B"
    AB = 3,
}
</code></pre>
<ul>
<li>the initializer can be used to map the value</li>
<li>the <code>blockId</code> attribute can be used to override the block id</li>
<li>the <code>block</code> attribute can be used to override the rendered string</li>
</ul>
<h3 id="Tip-dropdown-for-non-enum-parameters"><a href="#Tip-dropdown-for-non-enum-parameters" class="headerlink" title="Tip: dropdown for non-enum parameters"></a>Tip: dropdown for non-enum parameters</h3><p>It’s possible to provide a drop-down for a parameter that is not an enum. It involves the following step:</p>
<ul>
<li>create an enum with desired drop down entry<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">enum Delimiters {
  //% block="new line"
  NewLine = 1,
  //% block=","
  Comma = 2
}
</code></pre>
</li>
<li>a function that takes the enum as parameter and returns the according value<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">//% blockId="delimiter_conv" block="%del"
export function delimiters(del : Delimiters) : string {
  switch(del) {
      case Delimiters.NewLine: return "\n";
      case Delimiters.Comma:  return ",";
      ...
  }
}
</code></pre>
</li>
<li>use the enum conversion function block id (<code>delimiter_conv</code>) as the value in the <code>block</code> parameter of your function<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">//% blockId="read_until" block="read until %del=delimiter_conv"
export function readUntil(del: string) : string {
  ...
}
</code></pre>
</li>
</ul>
<h2 id="Docs-and-default-values"><a href="#Docs-and-default-values" class="headerlink" title="Docs and default values"></a>Docs and default values</h2><p>The JSDoc comment is automatically used as the help for the block.</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">/**
 * Scroll a number on the screen. If the number fits on the screen (i.e. is a single digit), do not scroll.
 * @param interval speed of scroll; eg: 150, 100, 200, -100
*/
//% help=functions/show-number
export function showNumber(value: number, interval: number = 150): void
{ }
</code></pre>
<ul>
<li>If <code>@param</code> annotation is available with an <code>eg:</code> section, the first<br>value is used as the shadow value.</li>
<li>An optional <code>help</code> attribute can be used to point to an specific documentation path.</li>
<li>If the parameter has a default value (<code>interval</code> in this case), it is <strong>not</strong> exposed in blocks.</li>
<li>If you want to include minimum and maximum value range for a numeric parameter, you can use square brackets with the range [min-max] after the parameter name in the <code>@param</code> annotation. It is important to include the shadow value if you are using range<ul>
<li><code>@param</code> power [0-7] a value in the range 0..7, where 0 is the lowest power and 7 is the highest. <code>eg:</code> 7</li>
</ul>
</li>
</ul>
<h2 id="Objects-and-Instance-methods"><a href="#Objects-and-Instance-methods" class="headerlink" title="Objects and Instance methods"></a>Objects and Instance methods</h2><p>It is possible to expose instance methods and object factories, either directly<br>or with a bit of flattening (which is recommended, as flat, C-style APIs map best to blocks).</p>
<h3 id="Direct"><a href="#Direct" class="headerlink" title="Direct"></a>Direct</h3><pre class=" language-typescript-ignore"><code class="language-typescript-ignore">//%
class Message {
    ...
    //% blockId="message_get_text" block="%this|text"
    public getText() { ... }
}
</code></pre>
<ul>
<li>when annotating an instance method, you need to specify the <code>%this</code> parameter in the block syntax definition.</li>
</ul>
<p>You will need to expose a factory method to create your objects as needed. For the example above, we add a function that creates the message:</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">//% blockId="create_message" block="create message|with %text"
export function createMessage(text: string) : Message {
    return new Message(text);
}
</code></pre>
<h3 id="Auto-create"><a href="#Auto-create" class="headerlink" title="Auto-create"></a>Auto-create</h3><p>If object has a reasonable default constructor, and it is harmless to call this<br>constructor even if the variable needs to be overwritten later, then it’s useful<br>to designate a parameter-less function as auto-create, like this:</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">namespace images {
    export function emptyImage(width = 5, height = 5): Image { ... }
}
//% autoCreate=images.emptyImage
class Image {
    ...
}
</code></pre>
<p>Now, when user adds a block referring to a method of <code>Image</code>, a global<br>variable will be automatically introduced and initialized with <code>images.emptyImage()</code>.</p>
<p>In cases when the default constructor has side effects (eg., configuring a pin),<br>or if the default value is most often overridden,<br>the <code>autoCreate</code> syntax should not be used.</p>
<h3 id="Fixed-Instance-Set"><a href="#Fixed-Instance-Set" class="headerlink" title="Fixed Instance Set"></a>Fixed Instance Set</h3><p>It is sometimes the case that there is only a fixed number of instances<br>of a given class. One example is object representing pins on an electronic board.<br>It is possible to expose these instances in a manner similar to an enum:</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">//% fixedInstances
class DigitalPin {
    ...
    //% blockId=device_set_digital_pin block="digital write|pin %name|to %value"
    //% blockNamespace=pins
    digitalWrite(value: number): void { ... }
}

namespace pins {
    //% fixedInstance
    let D0: DigitalPin;
    //% fixedInstance
    let D1: DigitalPin;
}
</code></pre>
<p>This will result in a block <code>digital write pin [D0] to [0]</code>, where the<br>first hold is a dropdown with <code>D0</code> and <code>D1</code>, and the second hole is a regular<br>integer value. The variables <code>D0</code> and <code>D1</code> can have additional annotations<br>(eg., <code>block=&quot;D#0&quot;</code>). Currently, only variables are supported with <code>fixedInstance</code><br>(<code>let</code> or <code>const</code>).</p>
<p>Fixed instances also support inheritance. For example, consider adding the following<br>declarations.</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">//% fixedInstances
class AnalogPin extends DigitalPin {
    ...
    //% blockId=device_set_analog_pin block="analog write|pin %name|to %value"
    //% blockNamespace=pins
    analogWrite(value: number): void { ... }
}

namespace pins {
    //% fixedInstance
    let A0: AnalogPin;
}
</code></pre>
<p>The <code>analog write</code> will have a single-option dropdown with <code>A0</code>, but<br>the optionals on <code>digital write</code> will be now <code>D0</code>, <code>D1</code> and <code>A0</code>.</p>
<p>Variables with <code>fixedInstance</code> annotations can be added anywhere, at the top-level,<br>even in different libraries or namespaces.</p>
<p>This feature is often used with <code>indexedInstance*</code> attributes.</p>
<p>It is also possible to define the instances to be used in blocks in TypeScript,<br>for example:</p>
<pre class=" language-typescript-ignore"><code class="language-typescript-ignore">namespace pins {
    //% fixedInstance whenUsed
    export const A7 = new AnalogPin(7);
}
</code></pre>
<p>The <code>whenUsed</code> annotation causes the variable to be only included in compilation<br>when it is used, even though it is initialized with something that can possibly<br>have side effects. This happens automatically when there is no initializer,<br>or the initializer is a simple constant, but for function calls and constructors<br>you have to include <code>whenUsed</code>.</p>
<h2 id="Ordering"><a href="#Ordering" class="headerlink" title="Ordering"></a>Ordering</h2><p>All blocks have a default <strong>weight</strong> of 50 that is used to sort them in the UI with the highest weight showing up first. To tweak the ordering,<br>simply annotate the function with the <code>weight</code> macro:</p>
<pre><code>//% weight=10
...
</code></pre><p>If given API is only for Blocks usage, and doesn’t make much sense in TypeScript<br>(for example, because there are alternative TypeScript APIs), you can use <code>//% hidden</code><br>flag to disable showing it in auto-completion.</p>
<h2 id="Grouping"><a href="#Grouping" class="headerlink" title="Grouping"></a>Grouping</h2><p>Use the <strong>blockGap</strong> macro to specify the distance to the next block in the toolbox. Combined with the weight parameter,<br>this macro allows to definte groups of blocks. The default <code>blockGap</code> value is <code>8</code>.</p>
<pre><code>//% blockGap=14
...
</code></pre><h2 id="Testing-your-Blocks"><a href="#Testing-your-Blocks" class="headerlink" title="Testing your Blocks"></a>Testing your Blocks</h2><p>We recommend to build your block APIs iteratively and try it out in the editor to get the “feel of it”.<br>To do so, the ideal setup is:</p>
<ul>
<li>run your target locally using <code>pxt serve</code></li>
<li>keep a code editor with the TypeScript opened where you can edit the APIs</li>
<li>refresh the browser and try out the changes on a dummy program.</li>
</ul>
<p>Interestingly, you can design your entire API without implementing it!</p>
<h2 id="Deprecating-Blocks"><a href="#Deprecating-Blocks" class="headerlink" title="Deprecating Blocks"></a>Deprecating Blocks</h2><p>To deprecate an existing API, you can add the <strong>deprecated</strong> attribute like so:</p>
<pre><code>//% deprecated=true
</code></pre><p>This will cause the API to still be usable in TypeScript, but prevent the block from appearing in the<br>Blockly toolbox. If a user tries to load a project that uses the old API, the project will still load<br>correctly as long as the TypeScript API is present. Any deprecated blocks in the project will appear in<br>the editor but not the toolbox.</p>
<h2 id="API-design-Tips-and-Tricks"><a href="#API-design-Tips-and-Tricks" class="headerlink" title="API design Tips and Tricks"></a>API design Tips and Tricks</h2><p>A few tips gathered while designing various APIs for the Block Editor.</p>
<ul>
<li><strong>Design for beginners</strong>: the block interface is for beginners. You’ll want to create a specific layer of C-like function for that purpose.</li>
<li><strong>Anything that snaps together will be tried by the user</strong>: your runtime should deal with invalid input with graceful degradation rather than abrupt crashes.<br>Some users will try to snap anything together - get ready for it.</li>
<li><strong>OO is cumbersome</strong> in blocks: we recommend using a C-like APIs – just function – rather than OO classes. It maps better to blocks.</li>
<li><strong>Keep the number of blocks small</strong>: there’s only so much space in the toolbox. Be specific about each API you want to see in Blocks.</li>
</ul>

</div>
</div>

<!-- 文档信息 -->
<div class="post-foot">
  <h3>文档信息</h3>
  <ul>
    <li>版权声明：自由转载-非商用-非衍生-保持署名（
      <a href="http://creativecommons.org/licenses/by-nc-nd/3.0/deed.zh">创意共享3.0许可证</a>）
    </li>
    <li>作者：Lian</li>
    <li>日期：2017年10月11日 19:10</li>
  </ul>
</div>
      


<div class="content-comment">
  <h2>留言</h2>
  
  
<div id="" class="item-comment">
  <p class="author">
    
    lian <span>说：</span>
  </p>

  <div class="content">
      <blockquote>
        <pre>引用xiaotian044500的发言：</pre>
        看来这么想的不在少数啊, 确实挺像的.
        </blockquote>
        哈哈
  </div>
    
</div>
		
</div>

<!-- 评论输入组件，填写数据：留言，称呼，电子邮件 -->

<div class="form-comment">
  <h2>
		我要发表看法
	</h2>


	<form method="post" action="" 
	 onsubmit="return pleaseWait()">
	 <!-- 留言正文 -->
	 
		
<p>
	<label for="comment-content">
		您的留言:
	</label>
</p>

<p>
	<textarea 
	id="comment-content" 
	name="content" 
	rows="10" cols="50">
	</textarea>
</p>

		<!-- 姓名 -->
	 
		
<p>
	<label for="comment-author">
		您的大名:
	</label>
</p>

<p>
	<input 
	id="comment-author" 
	name="author" 
	size="30" 
	value=""
	pattern="^.*+$"
	required
	>
	<span class="hint">
			 «-必填
	</span
</p>


		<!-- 微信 -->
	 
		
<p>
	<label for="comment-wechat">
		您的微信:
	</label>
</p>

<p>
	<input 
	id="comment-wechat" 
	name="wechat" 
	size="30" 
	value=""
	pattern="^[a-zA-Zd_]{5,}$"
	
	>
	<span class="hint">
			 «-选填，不公开
	</span
</p>


		<!-- 电子邮箱 -->
		
		
<p>
	<label for="comment-email">
		电子邮箱：
	</label>
</p>

<p>
	<input 
	id="comment-email" 
	name="email" 
	size="30" 
	value=""
	pattern="^[a-zA-Z0-9_-]+@[a-zA-Z0-9_-]+(.[a-zA-Z0-9_-]+)+$"
	
	>
	<span class="hint">
			 «-选填，不公开
	</span
</p>


		<p>
			<input type="submit" class="submit-button" value="发表">
			<span class="hint"> «- 点击按钮</span>
		</p>
	</form>

</div>


<!-- data:{
	name:'',
	type:'passwor',
	label:'您的大名',
	hint:'',
	pattern:'[A-z]{3}',
	required:"required"
} -->

<div class="footer">
  Copyright @ <a href="/">lian</a> | 2009-2018
</div>
</div>
</body>

</html>

